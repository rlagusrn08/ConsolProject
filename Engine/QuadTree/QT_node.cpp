#include "PreCompiledHeader.h"
#include "QT_NODE.h"
#include "QuadTree.h"

QTNode::QTNode(const Bounds& bounds, Actor* owner, int depth)
	: bounds(bounds), depth(depth)
{
	m_pOwner = owner;
}

QTNode::~QTNode()
{
	Clear();
}

void QTNode::Insert(QTNode* node)
{
	NodeIndex result = TestRegion(node->Get_Bounds());

	if (result == NodeIndex::STRADDLING)
	{
		points.push_back(node->Get_Owner());
	}
	else if (result != NodeIndex::OUT_OF_AREA)
	{
		if (Subdivide())
		{
			if (result == NodeIndex::TOP_LEFT)
			{
				topLeft->Insert(node);
			}
			else if (result == NodeIndex::TOP_RIGHT)
			{
				topRight->Insert(node);
			}
			else if (result == NodeIndex::BOTTOM_LEFT)
			{
				bottomLeft->Insert(node);
			}
			else if (result == NodeIndex::BOTTOM_RIGHT)
			{
				bottomRight->Insert(node);
			}
		}
		else
		{
			points.push_back(node->Get_Owner());
		}
	}
}

void QTNode::Query(const Bounds& queryBounds, std::vector<QTNode*>& possibleNodes)
{
	possibleNodes.push_back(this);

	if (isDivided)
	{
		vector<NodeIndex> quads = GetQuads(queryBounds);

		for (NodeIndex& index : quads)
		{
			if (index == NodeIndex::TOP_LEFT)
			{
				topLeft->Query(queryBounds, possibleNodes);
			}
			else if (index == NodeIndex::TOP_RIGHT)
			{
				topRight->Query(queryBounds, possibleNodes);
			}
			else if (index == NodeIndex::BOTTOM_LEFT)
			{
				bottomLeft->Query(queryBounds, possibleNodes);
			}
			else if (index == NodeIndex::BOTTOM_RIGHT)
			{
				bottomRight->Query(queryBounds, possibleNodes);
			}
		}
	}
}

void QTNode::Clear()
{
	points.clear();
	if (isDivided)
	{
		if(topLeft != nullptr)
			topLeft->Clear();
		if(topRight != nullptr)
			topRight->Clear();
		if(bottomLeft != nullptr)
			bottomLeft->Clear();
		if (bottomRight != nullptr)
			bottomRight->Clear();

		ClearChildren();
	}
	isDivided = false;
}

NodeIndex QTNode::TestRegion(const Bounds& other)
{
	vector<NodeIndex> quads = GetQuads(other);

	if (quads.size() == 0)
	{
		return NodeIndex::OUT_OF_AREA;
	}

	if (quads.size() == 1)
	{
		return quads[0];
	}

	return NodeIndex::STRADDLING;
}

vector<NodeIndex> QTNode::GetQuads(const Bounds& other)
{
	std::vector<NodeIndex> quads;

	// 영역 계산에 필요한 변수.
	float x = this->bounds.X();
	float y = this->bounds.Y();
	float halfWidth = this->bounds.Width() / 2.0f;
	float halfHeight = this->bounds.Height() / 2.0f;
	float centerX = x + halfWidth;
	float centerY = y + halfHeight;

	// 왼쪽 영역이랑 겹치는지 확인.
	bool left = other.X() < centerX && other.MaxX() >= x;

	// 오른쪽 영역이랑 겹치는지 확인.
	bool right = other.MaxX() >= centerX && other.X() < this->bounds.MaxX();

	// 위쪽 영역이랑 겹치는지 확인.
	bool top = other.Y() < centerY && other.MaxY() >= y;

	// 아래쪽 영역이랑 겹치는지 확인.
	bool bottom = other.MaxY() >= centerY && other.Y() < this->bounds.MaxY();

	if (top && left)
	{
		quads.emplace_back(NodeIndex::TOP_LEFT);
	}
	if (top && right)
	{
		quads.emplace_back(NodeIndex::TOP_RIGHT);
	}
	if (bottom && left)
	{
		quads.emplace_back(NodeIndex::BOTTOM_LEFT);
	}
	if (bottom && right)
	{
		quads.emplace_back(NodeIndex::BOTTOM_RIGHT);
	}

	return quads;
}

bool QTNode::Subdivide()
{
	// 최대 깊이에 도달했으면 더이상 안나눔.
	if (depth == QuadTree::maxDepth)
	{
		return false;
	}

	// 아직 분할 안됐으면, 분할 진행.
	if (!isDivided)
	{
		isDivided = true;
		// 영역을 나누기 위한 값 계산.
		float x = bounds.X();
		float y = bounds.Y();
		float halfWidth = bounds.Width() / 2;
		float halfHeight = bounds.Height() / 2;

		// 각 4분면의 자식 객체 생성.
		topLeft = new QTNode(Bounds(x, y, halfWidth, halfHeight), nullptr, depth + 1);
		topRight = new QTNode(Bounds(x + halfWidth, y, halfWidth, halfHeight), nullptr, depth + 1);
		bottomLeft = new QTNode(Bounds(x, y + halfHeight, halfWidth, halfHeight), nullptr, depth + 1);
		bottomRight = new QTNode(Bounds(x + halfWidth, y + halfHeight, halfWidth, halfHeight), nullptr, depth + 1);
	}

	return true;
}


bool QTNode::IsDivided()
{
	return topLeft != nullptr;
}

void QTNode::ClearChildren()
{
	if (isDivided)
	{
		SafeDelete(topLeft);
		SafeDelete(topRight);
		SafeDelete(bottomLeft);
		SafeDelete(bottomRight);
	}
}


